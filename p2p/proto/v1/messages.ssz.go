// Code generated by fastssz. DO NOT EDIT.
// Hash: 777c711a8bf3abf48991173bda18daa32a11d1f0ab49762cd43f940dde3fabe2
// Version: 0.1.2
package qitmeer_p2p_v1

import (
	ssz "github.com/ferranbt/fastssz"
)

// MarshalSSZ ssz marshals the ChainState object
func (c *ChainState) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(c)
}

// MarshalSSZTo ssz marshals the ChainState object to a target array
func (c *ChainState) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(61)

	// Field (0) 'GenesisHash'
	if c.GenesisHash == nil {
		c.GenesisHash = new(Hash)
	}
	if dst, err = c.GenesisHash.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (1) 'ProtocolVersion'
	dst = ssz.MarshalUint32(dst, c.ProtocolVersion)

	// Field (2) 'Timestamp'
	dst = ssz.MarshalUint64(dst, c.Timestamp)

	// Field (3) 'Services'
	dst = ssz.MarshalUint64(dst, c.Services)

	// Field (4) 'DisableRelayTx'
	dst = ssz.MarshalBool(dst, c.DisableRelayTx)

	// Offset (5) 'GraphState'
	dst = ssz.WriteOffset(dst, offset)
	if c.GraphState == nil {
		c.GraphState = new(GraphState)
	}
	offset += c.GraphState.SizeSSZ()

	// Offset (6) 'UserAgent'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(c.UserAgent)

	// Field (5) 'GraphState'
	if dst, err = c.GraphState.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (6) 'UserAgent'
	if size := len(c.UserAgent); size > 256 {
		err = ssz.ErrBytesLengthFn("ChainState.UserAgent", size, 256)
		return
	}
	dst = append(dst, c.UserAgent...)

	return
}

// UnmarshalSSZ ssz unmarshals the ChainState object
func (c *ChainState) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 61 {
		return ssz.ErrSize
	}

	tail := buf
	var o5, o6 uint64

	// Field (0) 'GenesisHash'
	if c.GenesisHash == nil {
		c.GenesisHash = new(Hash)
	}
	if err = c.GenesisHash.UnmarshalSSZ(buf[0:32]); err != nil {
		return err
	}

	// Field (1) 'ProtocolVersion'
	c.ProtocolVersion = ssz.UnmarshallUint32(buf[32:36])

	// Field (2) 'Timestamp'
	c.Timestamp = ssz.UnmarshallUint64(buf[36:44])

	// Field (3) 'Services'
	c.Services = ssz.UnmarshallUint64(buf[44:52])

	// Field (4) 'DisableRelayTx'
	c.DisableRelayTx = ssz.UnmarshalBool(buf[52:53])

	// Offset (5) 'GraphState'
	if o5 = ssz.ReadOffset(buf[53:57]); o5 > size {
		return ssz.ErrOffset
	}

	if o5 < 61 {
		return ssz.ErrInvalidVariableOffset
	}

	// Offset (6) 'UserAgent'
	if o6 = ssz.ReadOffset(buf[57:61]); o6 > size || o5 > o6 {
		return ssz.ErrOffset
	}

	// Field (5) 'GraphState'
	{
		buf = tail[o5:o6]
		if c.GraphState == nil {
			c.GraphState = new(GraphState)
		}
		if err = c.GraphState.UnmarshalSSZ(buf); err != nil {
			return err
		}
	}

	// Field (6) 'UserAgent'
	{
		buf = tail[o6:]
		if len(buf) > 256 {
			return ssz.ErrBytesLength
		}
		if cap(c.UserAgent) == 0 {
			c.UserAgent = make([]byte, 0, len(buf))
		}
		c.UserAgent = append(c.UserAgent, buf...)
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the ChainState object
func (c *ChainState) SizeSSZ() (size int) {
	size = 61

	// Field (5) 'GraphState'
	if c.GraphState == nil {
		c.GraphState = new(GraphState)
	}
	size += c.GraphState.SizeSSZ()

	// Field (6) 'UserAgent'
	size += len(c.UserAgent)

	return
}

// HashTreeRoot ssz hashes the ChainState object
func (c *ChainState) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(c)
}

// HashTreeRootWith ssz hashes the ChainState object with a hasher
func (c *ChainState) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'GenesisHash'
	if c.GenesisHash == nil {
		c.GenesisHash = new(Hash)
	}
	if err = c.GenesisHash.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (1) 'ProtocolVersion'
	hh.PutUint32(c.ProtocolVersion)

	// Field (2) 'Timestamp'
	hh.PutUint64(c.Timestamp)

	// Field (3) 'Services'
	hh.PutUint64(c.Services)

	// Field (4) 'DisableRelayTx'
	hh.PutBool(c.DisableRelayTx)

	// Field (5) 'GraphState'
	if err = c.GraphState.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (6) 'UserAgent'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(c.UserAgent))
		if byteLen > 256 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.PutBytes(c.UserAgent)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (256+31)/32)
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the ChainState object
func (c *ChainState) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(c)
}

// MarshalSSZ ssz marshals the FilterAddRequest object
func (f *FilterAddRequest) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(f)
}

// MarshalSSZTo ssz marshals the FilterAddRequest object to a target array
func (f *FilterAddRequest) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(4)

	// Offset (0) 'Data'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(f.Data)

	// Field (0) 'Data'
	if size := len(f.Data); size > 256 {
		err = ssz.ErrBytesLengthFn("FilterAddRequest.Data", size, 256)
		return
	}
	dst = append(dst, f.Data...)

	return
}

// UnmarshalSSZ ssz unmarshals the FilterAddRequest object
func (f *FilterAddRequest) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 4 {
		return ssz.ErrSize
	}

	tail := buf
	var o0 uint64

	// Offset (0) 'Data'
	if o0 = ssz.ReadOffset(buf[0:4]); o0 > size {
		return ssz.ErrOffset
	}

	if o0 < 4 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (0) 'Data'
	{
		buf = tail[o0:]
		if len(buf) > 256 {
			return ssz.ErrBytesLength
		}
		if cap(f.Data) == 0 {
			f.Data = make([]byte, 0, len(buf))
		}
		f.Data = append(f.Data, buf...)
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the FilterAddRequest object
func (f *FilterAddRequest) SizeSSZ() (size int) {
	size = 4

	// Field (0) 'Data'
	size += len(f.Data)

	return
}

// HashTreeRoot ssz hashes the FilterAddRequest object
func (f *FilterAddRequest) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(f)
}

// HashTreeRootWith ssz hashes the FilterAddRequest object with a hasher
func (f *FilterAddRequest) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Data'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(f.Data))
		if byteLen > 256 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.PutBytes(f.Data)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (256+31)/32)
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the FilterAddRequest object
func (f *FilterAddRequest) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(f)
}

// MarshalSSZ ssz marshals the FilterClearRequest object
func (f *FilterClearRequest) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(f)
}

// MarshalSSZTo ssz marshals the FilterClearRequest object to a target array
func (f *FilterClearRequest) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	return
}

// UnmarshalSSZ ssz unmarshals the FilterClearRequest object
func (f *FilterClearRequest) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 0 {
		return ssz.ErrSize
	}

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the FilterClearRequest object
func (f *FilterClearRequest) SizeSSZ() (size int) {
	size = 0
	return
}

// HashTreeRoot ssz hashes the FilterClearRequest object
func (f *FilterClearRequest) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(f)
}

// HashTreeRootWith ssz hashes the FilterClearRequest object with a hasher
func (f *FilterClearRequest) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the FilterClearRequest object
func (f *FilterClearRequest) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(f)
}

// MarshalSSZ ssz marshals the FilterLoadRequest object
func (f *FilterLoadRequest) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(f)
}

// MarshalSSZTo ssz marshals the FilterLoadRequest object to a target array
func (f *FilterLoadRequest) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(28)

	// Offset (0) 'Filter'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(f.Filter)

	// Field (1) 'HashFuncs'
	dst = ssz.MarshalUint64(dst, f.HashFuncs)

	// Field (2) 'Tweak'
	dst = ssz.MarshalUint64(dst, f.Tweak)

	// Field (3) 'Flags'
	dst = ssz.MarshalUint64(dst, f.Flags)

	// Field (0) 'Filter'
	if size := len(f.Filter); size > 256 {
		err = ssz.ErrBytesLengthFn("FilterLoadRequest.Filter", size, 256)
		return
	}
	dst = append(dst, f.Filter...)

	return
}

// UnmarshalSSZ ssz unmarshals the FilterLoadRequest object
func (f *FilterLoadRequest) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 28 {
		return ssz.ErrSize
	}

	tail := buf
	var o0 uint64

	// Offset (0) 'Filter'
	if o0 = ssz.ReadOffset(buf[0:4]); o0 > size {
		return ssz.ErrOffset
	}

	if o0 < 28 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (1) 'HashFuncs'
	f.HashFuncs = ssz.UnmarshallUint64(buf[4:12])

	// Field (2) 'Tweak'
	f.Tweak = ssz.UnmarshallUint64(buf[12:20])

	// Field (3) 'Flags'
	f.Flags = ssz.UnmarshallUint64(buf[20:28])

	// Field (0) 'Filter'
	{
		buf = tail[o0:]
		if len(buf) > 256 {
			return ssz.ErrBytesLength
		}
		if cap(f.Filter) == 0 {
			f.Filter = make([]byte, 0, len(buf))
		}
		f.Filter = append(f.Filter, buf...)
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the FilterLoadRequest object
func (f *FilterLoadRequest) SizeSSZ() (size int) {
	size = 28

	// Field (0) 'Filter'
	size += len(f.Filter)

	return
}

// HashTreeRoot ssz hashes the FilterLoadRequest object
func (f *FilterLoadRequest) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(f)
}

// HashTreeRootWith ssz hashes the FilterLoadRequest object with a hasher
func (f *FilterLoadRequest) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Filter'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(f.Filter))
		if byteLen > 256 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.PutBytes(f.Filter)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (256+31)/32)
	}

	// Field (1) 'HashFuncs'
	hh.PutUint64(f.HashFuncs)

	// Field (2) 'Tweak'
	hh.PutUint64(f.Tweak)

	// Field (3) 'Flags'
	hh.PutUint64(f.Flags)

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the FilterLoadRequest object
func (f *FilterLoadRequest) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(f)
}

// MarshalSSZ ssz marshals the GetBlockDatas object
func (g *GetBlockDatas) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(g)
}

// MarshalSSZTo ssz marshals the GetBlockDatas object to a target array
func (g *GetBlockDatas) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(4)

	// Offset (0) 'Locator'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(g.Locator) * 32

	// Field (0) 'Locator'
	if size := len(g.Locator); size > 2000 {
		err = ssz.ErrListTooBigFn("GetBlockDatas.Locator", size, 2000)
		return
	}
	for ii := 0; ii < len(g.Locator); ii++ {
		if dst, err = g.Locator[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	return
}

// UnmarshalSSZ ssz unmarshals the GetBlockDatas object
func (g *GetBlockDatas) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 4 {
		return ssz.ErrSize
	}

	tail := buf
	var o0 uint64

	// Offset (0) 'Locator'
	if o0 = ssz.ReadOffset(buf[0:4]); o0 > size {
		return ssz.ErrOffset
	}

	if o0 < 4 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (0) 'Locator'
	{
		buf = tail[o0:]
		num, err := ssz.DivideInt2(len(buf), 32, 2000)
		if err != nil {
			return err
		}
		g.Locator = make([]*Hash, num)
		for ii := 0; ii < num; ii++ {
			if g.Locator[ii] == nil {
				g.Locator[ii] = new(Hash)
			}
			if err = g.Locator[ii].UnmarshalSSZ(buf[ii*32 : (ii+1)*32]); err != nil {
				return err
			}
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the GetBlockDatas object
func (g *GetBlockDatas) SizeSSZ() (size int) {
	size = 4

	// Field (0) 'Locator'
	size += len(g.Locator) * 32

	return
}

// HashTreeRoot ssz hashes the GetBlockDatas object
func (g *GetBlockDatas) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(g)
}

// HashTreeRootWith ssz hashes the GetBlockDatas object with a hasher
func (g *GetBlockDatas) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Locator'
	{
		subIndx := hh.Index()
		num := uint64(len(g.Locator))
		if num > 2000 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range g.Locator {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 2000)
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the GetBlockDatas object
func (g *GetBlockDatas) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(g)
}

// MarshalSSZ ssz marshals the BlockDatas object
func (b *BlockDatas) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(b)
}

// MarshalSSZTo ssz marshals the BlockDatas object to a target array
func (b *BlockDatas) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(4)

	// Offset (0) 'Locator'
	dst = ssz.WriteOffset(dst, offset)
	for ii := 0; ii < len(b.Locator); ii++ {
		offset += 4
		offset += b.Locator[ii].SizeSSZ()
	}

	// Field (0) 'Locator'
	if size := len(b.Locator); size > 2000 {
		err = ssz.ErrListTooBigFn("BlockDatas.Locator", size, 2000)
		return
	}
	{
		offset = 4 * len(b.Locator)
		for ii := 0; ii < len(b.Locator); ii++ {
			dst = ssz.WriteOffset(dst, offset)
			offset += b.Locator[ii].SizeSSZ()
		}
	}
	for ii := 0; ii < len(b.Locator); ii++ {
		if dst, err = b.Locator[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	return
}

// UnmarshalSSZ ssz unmarshals the BlockDatas object
func (b *BlockDatas) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 4 {
		return ssz.ErrSize
	}

	tail := buf
	var o0 uint64

	// Offset (0) 'Locator'
	if o0 = ssz.ReadOffset(buf[0:4]); o0 > size {
		return ssz.ErrOffset
	}

	if o0 < 4 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (0) 'Locator'
	{
		buf = tail[o0:]
		num, err := ssz.DecodeDynamicLength(buf, 2000)
		if err != nil {
			return err
		}
		b.Locator = make([]*BlockData, num)
		err = ssz.UnmarshalDynamic(buf, num, func(indx int, buf []byte) (err error) {
			if b.Locator[indx] == nil {
				b.Locator[indx] = new(BlockData)
			}
			if err = b.Locator[indx].UnmarshalSSZ(buf); err != nil {
				return err
			}
			return nil
		})
		if err != nil {
			return err
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the BlockDatas object
func (b *BlockDatas) SizeSSZ() (size int) {
	size = 4

	// Field (0) 'Locator'
	for ii := 0; ii < len(b.Locator); ii++ {
		size += 4
		size += b.Locator[ii].SizeSSZ()
	}

	return
}

// HashTreeRoot ssz hashes the BlockDatas object
func (b *BlockDatas) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(b)
}

// HashTreeRootWith ssz hashes the BlockDatas object with a hasher
func (b *BlockDatas) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Locator'
	{
		subIndx := hh.Index()
		num := uint64(len(b.Locator))
		if num > 2000 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range b.Locator {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 2000)
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the BlockDatas object
func (b *BlockDatas) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(b)
}

// MarshalSSZ ssz marshals the BlockData object
func (b *BlockData) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(b)
}

// MarshalSSZTo ssz marshals the BlockData object to a target array
func (b *BlockData) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(4)

	// Offset (0) 'BlockBytes'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(b.BlockBytes)

	// Field (0) 'BlockBytes'
	if size := len(b.BlockBytes); size > 1048576 {
		err = ssz.ErrBytesLengthFn("BlockData.BlockBytes", size, 1048576)
		return
	}
	dst = append(dst, b.BlockBytes...)

	return
}

// UnmarshalSSZ ssz unmarshals the BlockData object
func (b *BlockData) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 4 {
		return ssz.ErrSize
	}

	tail := buf
	var o0 uint64

	// Offset (0) 'BlockBytes'
	if o0 = ssz.ReadOffset(buf[0:4]); o0 > size {
		return ssz.ErrOffset
	}

	if o0 < 4 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (0) 'BlockBytes'
	{
		buf = tail[o0:]
		if len(buf) > 1048576 {
			return ssz.ErrBytesLength
		}
		if cap(b.BlockBytes) == 0 {
			b.BlockBytes = make([]byte, 0, len(buf))
		}
		b.BlockBytes = append(b.BlockBytes, buf...)
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the BlockData object
func (b *BlockData) SizeSSZ() (size int) {
	size = 4

	// Field (0) 'BlockBytes'
	size += len(b.BlockBytes)

	return
}

// HashTreeRoot ssz hashes the BlockData object
func (b *BlockData) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(b)
}

// HashTreeRootWith ssz hashes the BlockData object with a hasher
func (b *BlockData) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'BlockBytes'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(b.BlockBytes))
		if byteLen > 1048576 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.PutBytes(b.BlockBytes)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (1048576+31)/32)
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the BlockData object
func (b *BlockData) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(b)
}

// MarshalSSZ ssz marshals the BroadcastBlock object
func (b *BroadcastBlock) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(b)
}

// MarshalSSZTo ssz marshals the BroadcastBlock object to a target array
func (b *BroadcastBlock) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(4)

	// Offset (0) 'Block'
	dst = ssz.WriteOffset(dst, offset)
	if b.Block == nil {
		b.Block = new(BlockData)
	}
	offset += b.Block.SizeSSZ()

	// Field (0) 'Block'
	if dst, err = b.Block.MarshalSSZTo(dst); err != nil {
		return
	}

	return
}

// UnmarshalSSZ ssz unmarshals the BroadcastBlock object
func (b *BroadcastBlock) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 4 {
		return ssz.ErrSize
	}

	tail := buf
	var o0 uint64

	// Offset (0) 'Block'
	if o0 = ssz.ReadOffset(buf[0:4]); o0 > size {
		return ssz.ErrOffset
	}

	if o0 < 4 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (0) 'Block'
	{
		buf = tail[o0:]
		if b.Block == nil {
			b.Block = new(BlockData)
		}
		if err = b.Block.UnmarshalSSZ(buf); err != nil {
			return err
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the BroadcastBlock object
func (b *BroadcastBlock) SizeSSZ() (size int) {
	size = 4

	// Field (0) 'Block'
	if b.Block == nil {
		b.Block = new(BlockData)
	}
	size += b.Block.SizeSSZ()

	return
}

// HashTreeRoot ssz hashes the BroadcastBlock object
func (b *BroadcastBlock) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(b)
}

// HashTreeRootWith ssz hashes the BroadcastBlock object with a hasher
func (b *BroadcastBlock) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Block'
	if err = b.Block.HashTreeRootWith(hh); err != nil {
		return
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the BroadcastBlock object
func (b *BroadcastBlock) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(b)
}

// MarshalSSZ ssz marshals the GetBlocks object
func (g *GetBlocks) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(g)
}

// MarshalSSZTo ssz marshals the GetBlocks object to a target array
func (g *GetBlocks) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(4)

	// Offset (0) 'Locator'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(g.Locator) * 32

	// Field (0) 'Locator'
	if size := len(g.Locator); size > 2000 {
		err = ssz.ErrListTooBigFn("GetBlocks.Locator", size, 2000)
		return
	}
	for ii := 0; ii < len(g.Locator); ii++ {
		if dst, err = g.Locator[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	return
}

// UnmarshalSSZ ssz unmarshals the GetBlocks object
func (g *GetBlocks) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 4 {
		return ssz.ErrSize
	}

	tail := buf
	var o0 uint64

	// Offset (0) 'Locator'
	if o0 = ssz.ReadOffset(buf[0:4]); o0 > size {
		return ssz.ErrOffset
	}

	if o0 < 4 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (0) 'Locator'
	{
		buf = tail[o0:]
		num, err := ssz.DivideInt2(len(buf), 32, 2000)
		if err != nil {
			return err
		}
		g.Locator = make([]*Hash, num)
		for ii := 0; ii < num; ii++ {
			if g.Locator[ii] == nil {
				g.Locator[ii] = new(Hash)
			}
			if err = g.Locator[ii].UnmarshalSSZ(buf[ii*32 : (ii+1)*32]); err != nil {
				return err
			}
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the GetBlocks object
func (g *GetBlocks) SizeSSZ() (size int) {
	size = 4

	// Field (0) 'Locator'
	size += len(g.Locator) * 32

	return
}

// HashTreeRoot ssz hashes the GetBlocks object
func (g *GetBlocks) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(g)
}

// HashTreeRootWith ssz hashes the GetBlocks object with a hasher
func (g *GetBlocks) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Locator'
	{
		subIndx := hh.Index()
		num := uint64(len(g.Locator))
		if num > 2000 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range g.Locator {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 2000)
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the GetBlocks object
func (g *GetBlocks) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(g)
}

// MarshalSSZ ssz marshals the DagBlocks object
func (d *DagBlocks) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(d)
}

// MarshalSSZTo ssz marshals the DagBlocks object to a target array
func (d *DagBlocks) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(4)

	// Offset (0) 'Blocks'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(d.Blocks) * 32

	// Field (0) 'Blocks'
	if size := len(d.Blocks); size > 2000 {
		err = ssz.ErrListTooBigFn("DagBlocks.Blocks", size, 2000)
		return
	}
	for ii := 0; ii < len(d.Blocks); ii++ {
		if dst, err = d.Blocks[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	return
}

// UnmarshalSSZ ssz unmarshals the DagBlocks object
func (d *DagBlocks) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 4 {
		return ssz.ErrSize
	}

	tail := buf
	var o0 uint64

	// Offset (0) 'Blocks'
	if o0 = ssz.ReadOffset(buf[0:4]); o0 > size {
		return ssz.ErrOffset
	}

	if o0 < 4 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (0) 'Blocks'
	{
		buf = tail[o0:]
		num, err := ssz.DivideInt2(len(buf), 32, 2000)
		if err != nil {
			return err
		}
		d.Blocks = make([]*Hash, num)
		for ii := 0; ii < num; ii++ {
			if d.Blocks[ii] == nil {
				d.Blocks[ii] = new(Hash)
			}
			if err = d.Blocks[ii].UnmarshalSSZ(buf[ii*32 : (ii+1)*32]); err != nil {
				return err
			}
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the DagBlocks object
func (d *DagBlocks) SizeSSZ() (size int) {
	size = 4

	// Field (0) 'Blocks'
	size += len(d.Blocks) * 32

	return
}

// HashTreeRoot ssz hashes the DagBlocks object
func (d *DagBlocks) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(d)
}

// HashTreeRootWith ssz hashes the DagBlocks object with a hasher
func (d *DagBlocks) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Blocks'
	{
		subIndx := hh.Index()
		num := uint64(len(d.Blocks))
		if num > 2000 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range d.Blocks {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 2000)
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the DagBlocks object
func (d *DagBlocks) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(d)
}

// MarshalSSZ ssz marshals the GraphState object
func (g *GraphState) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(g)
}

// MarshalSSZTo ssz marshals the GraphState object to a target array
func (g *GraphState) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(20)

	// Field (0) 'Total'
	dst = ssz.MarshalUint32(dst, g.Total)

	// Field (1) 'Layer'
	dst = ssz.MarshalUint32(dst, g.Layer)

	// Field (2) 'MainHeight'
	dst = ssz.MarshalUint32(dst, g.MainHeight)

	// Field (3) 'MainOrder'
	dst = ssz.MarshalUint32(dst, g.MainOrder)

	// Offset (4) 'Tips'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(g.Tips) * 32

	// Field (4) 'Tips'
	if size := len(g.Tips); size > 100 {
		err = ssz.ErrListTooBigFn("GraphState.Tips", size, 100)
		return
	}
	for ii := 0; ii < len(g.Tips); ii++ {
		if dst, err = g.Tips[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	return
}

// UnmarshalSSZ ssz unmarshals the GraphState object
func (g *GraphState) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 20 {
		return ssz.ErrSize
	}

	tail := buf
	var o4 uint64

	// Field (0) 'Total'
	g.Total = ssz.UnmarshallUint32(buf[0:4])

	// Field (1) 'Layer'
	g.Layer = ssz.UnmarshallUint32(buf[4:8])

	// Field (2) 'MainHeight'
	g.MainHeight = ssz.UnmarshallUint32(buf[8:12])

	// Field (3) 'MainOrder'
	g.MainOrder = ssz.UnmarshallUint32(buf[12:16])

	// Offset (4) 'Tips'
	if o4 = ssz.ReadOffset(buf[16:20]); o4 > size {
		return ssz.ErrOffset
	}

	if o4 < 20 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (4) 'Tips'
	{
		buf = tail[o4:]
		num, err := ssz.DivideInt2(len(buf), 32, 100)
		if err != nil {
			return err
		}
		g.Tips = make([]*Hash, num)
		for ii := 0; ii < num; ii++ {
			if g.Tips[ii] == nil {
				g.Tips[ii] = new(Hash)
			}
			if err = g.Tips[ii].UnmarshalSSZ(buf[ii*32 : (ii+1)*32]); err != nil {
				return err
			}
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the GraphState object
func (g *GraphState) SizeSSZ() (size int) {
	size = 20

	// Field (4) 'Tips'
	size += len(g.Tips) * 32

	return
}

// HashTreeRoot ssz hashes the GraphState object
func (g *GraphState) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(g)
}

// HashTreeRootWith ssz hashes the GraphState object with a hasher
func (g *GraphState) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Total'
	hh.PutUint32(g.Total)

	// Field (1) 'Layer'
	hh.PutUint32(g.Layer)

	// Field (2) 'MainHeight'
	hh.PutUint32(g.MainHeight)

	// Field (3) 'MainOrder'
	hh.PutUint32(g.MainOrder)

	// Field (4) 'Tips'
	{
		subIndx := hh.Index()
		num := uint64(len(g.Tips))
		if num > 100 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range g.Tips {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 100)
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the GraphState object
func (g *GraphState) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(g)
}

// MarshalSSZ ssz marshals the Inventory object
func (i *Inventory) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(i)
}

// MarshalSSZTo ssz marshals the Inventory object to a target array
func (i *Inventory) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(4)

	// Offset (0) 'Invs'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(i.Invs) * 36

	// Field (0) 'Invs'
	if size := len(i.Invs); size > 20000 {
		err = ssz.ErrListTooBigFn("Inventory.Invs", size, 20000)
		return
	}
	for ii := 0; ii < len(i.Invs); ii++ {
		if dst, err = i.Invs[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	return
}

// UnmarshalSSZ ssz unmarshals the Inventory object
func (i *Inventory) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 4 {
		return ssz.ErrSize
	}

	tail := buf
	var o0 uint64

	// Offset (0) 'Invs'
	if o0 = ssz.ReadOffset(buf[0:4]); o0 > size {
		return ssz.ErrOffset
	}

	if o0 < 4 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (0) 'Invs'
	{
		buf = tail[o0:]
		num, err := ssz.DivideInt2(len(buf), 36, 20000)
		if err != nil {
			return err
		}
		i.Invs = make([]*InvVect, num)
		for ii := 0; ii < num; ii++ {
			if i.Invs[ii] == nil {
				i.Invs[ii] = new(InvVect)
			}
			if err = i.Invs[ii].UnmarshalSSZ(buf[ii*36 : (ii+1)*36]); err != nil {
				return err
			}
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the Inventory object
func (i *Inventory) SizeSSZ() (size int) {
	size = 4

	// Field (0) 'Invs'
	size += len(i.Invs) * 36

	return
}

// HashTreeRoot ssz hashes the Inventory object
func (i *Inventory) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(i)
}

// HashTreeRootWith ssz hashes the Inventory object with a hasher
func (i *Inventory) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Invs'
	{
		subIndx := hh.Index()
		num := uint64(len(i.Invs))
		if num > 20000 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range i.Invs {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 20000)
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the Inventory object
func (i *Inventory) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(i)
}

// MarshalSSZ ssz marshals the InvVect object
func (i *InvVect) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(i)
}

// MarshalSSZTo ssz marshals the InvVect object to a target array
func (i *InvVect) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Type'
	dst = ssz.MarshalUint32(dst, i.Type)

	// Field (1) 'Hash'
	if i.Hash == nil {
		i.Hash = new(Hash)
	}
	if dst, err = i.Hash.MarshalSSZTo(dst); err != nil {
		return
	}

	return
}

// UnmarshalSSZ ssz unmarshals the InvVect object
func (i *InvVect) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 36 {
		return ssz.ErrSize
	}

	// Field (0) 'Type'
	i.Type = ssz.UnmarshallUint32(buf[0:4])

	// Field (1) 'Hash'
	if i.Hash == nil {
		i.Hash = new(Hash)
	}
	if err = i.Hash.UnmarshalSSZ(buf[4:36]); err != nil {
		return err
	}

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the InvVect object
func (i *InvVect) SizeSSZ() (size int) {
	size = 36
	return
}

// HashTreeRoot ssz hashes the InvVect object
func (i *InvVect) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(i)
}

// HashTreeRootWith ssz hashes the InvVect object with a hasher
func (i *InvVect) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Type'
	hh.PutUint32(i.Type)

	// Field (1) 'Hash'
	if i.Hash == nil {
		i.Hash = new(Hash)
	}
	if err = i.Hash.HashTreeRootWith(hh); err != nil {
		return
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the InvVect object
func (i *InvVect) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(i)
}

// MarshalSSZ ssz marshals the MemPoolRequest object
func (m *MemPoolRequest) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(m)
}

// MarshalSSZTo ssz marshals the MemPoolRequest object to a target array
func (m *MemPoolRequest) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'TxsNum'
	dst = ssz.MarshalUint64(dst, m.TxsNum)

	return
}

// UnmarshalSSZ ssz unmarshals the MemPoolRequest object
func (m *MemPoolRequest) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 8 {
		return ssz.ErrSize
	}

	// Field (0) 'TxsNum'
	m.TxsNum = ssz.UnmarshallUint64(buf[0:8])

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the MemPoolRequest object
func (m *MemPoolRequest) SizeSSZ() (size int) {
	size = 8
	return
}

// HashTreeRoot ssz hashes the MemPoolRequest object
func (m *MemPoolRequest) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(m)
}

// HashTreeRootWith ssz hashes the MemPoolRequest object with a hasher
func (m *MemPoolRequest) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'TxsNum'
	hh.PutUint64(m.TxsNum)

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the MemPoolRequest object
func (m *MemPoolRequest) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(m)
}

// MarshalSSZ ssz marshals the MemPoolRespond object
func (m *MemPoolRespond) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(m)
}

// MarshalSSZTo ssz marshals the MemPoolRespond object to a target array
func (m *MemPoolRespond) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'TxsNum'
	dst = ssz.MarshalUint64(dst, m.TxsNum)

	return
}

// UnmarshalSSZ ssz unmarshals the MemPoolRespond object
func (m *MemPoolRespond) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 8 {
		return ssz.ErrSize
	}

	// Field (0) 'TxsNum'
	m.TxsNum = ssz.UnmarshallUint64(buf[0:8])

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the MemPoolRespond object
func (m *MemPoolRespond) SizeSSZ() (size int) {
	size = 8
	return
}

// HashTreeRoot ssz hashes the MemPoolRespond object
func (m *MemPoolRespond) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(m)
}

// HashTreeRootWith ssz hashes the MemPoolRespond object with a hasher
func (m *MemPoolRespond) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'TxsNum'
	hh.PutUint64(m.TxsNum)

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the MemPoolRespond object
func (m *MemPoolRespond) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(m)
}

// MarshalSSZ ssz marshals the MerkleBlockRequest object
func (m *MerkleBlockRequest) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(m)
}

// MarshalSSZTo ssz marshals the MerkleBlockRequest object to a target array
func (m *MerkleBlockRequest) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(4)

	// Offset (0) 'Hashes'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(m.Hashes) * 32

	// Field (0) 'Hashes'
	if size := len(m.Hashes); size > 2000 {
		err = ssz.ErrListTooBigFn("MerkleBlockRequest.Hashes", size, 2000)
		return
	}
	for ii := 0; ii < len(m.Hashes); ii++ {
		if dst, err = m.Hashes[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	return
}

// UnmarshalSSZ ssz unmarshals the MerkleBlockRequest object
func (m *MerkleBlockRequest) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 4 {
		return ssz.ErrSize
	}

	tail := buf
	var o0 uint64

	// Offset (0) 'Hashes'
	if o0 = ssz.ReadOffset(buf[0:4]); o0 > size {
		return ssz.ErrOffset
	}

	if o0 < 4 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (0) 'Hashes'
	{
		buf = tail[o0:]
		num, err := ssz.DivideInt2(len(buf), 32, 2000)
		if err != nil {
			return err
		}
		m.Hashes = make([]*Hash, num)
		for ii := 0; ii < num; ii++ {
			if m.Hashes[ii] == nil {
				m.Hashes[ii] = new(Hash)
			}
			if err = m.Hashes[ii].UnmarshalSSZ(buf[ii*32 : (ii+1)*32]); err != nil {
				return err
			}
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the MerkleBlockRequest object
func (m *MerkleBlockRequest) SizeSSZ() (size int) {
	size = 4

	// Field (0) 'Hashes'
	size += len(m.Hashes) * 32

	return
}

// HashTreeRoot ssz hashes the MerkleBlockRequest object
func (m *MerkleBlockRequest) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(m)
}

// HashTreeRootWith ssz hashes the MerkleBlockRequest object with a hasher
func (m *MerkleBlockRequest) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Hashes'
	{
		subIndx := hh.Index()
		num := uint64(len(m.Hashes))
		if num > 2000 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range m.Hashes {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 2000)
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the MerkleBlockRequest object
func (m *MerkleBlockRequest) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(m)
}

// MarshalSSZ ssz marshals the MerkleBlock object
func (m *MerkleBlock) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(m)
}

// MarshalSSZTo ssz marshals the MerkleBlock object to a target array
func (m *MerkleBlock) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(20)

	// Offset (0) 'Header'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(m.Header)

	// Field (1) 'Transactions'
	dst = ssz.MarshalUint64(dst, m.Transactions)

	// Offset (2) 'Hashes'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(m.Hashes) * 32

	// Offset (3) 'Flags'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(m.Flags)

	// Field (0) 'Header'
	if size := len(m.Header); size > 256 {
		err = ssz.ErrBytesLengthFn("MerkleBlock.Header", size, 256)
		return
	}
	dst = append(dst, m.Header...)

	// Field (2) 'Hashes'
	if size := len(m.Hashes); size > 104858 {
		err = ssz.ErrListTooBigFn("MerkleBlock.Hashes", size, 104858)
		return
	}
	for ii := 0; ii < len(m.Hashes); ii++ {
		if dst, err = m.Hashes[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (3) 'Flags'
	if size := len(m.Flags); size > 256 {
		err = ssz.ErrBytesLengthFn("MerkleBlock.Flags", size, 256)
		return
	}
	dst = append(dst, m.Flags...)

	return
}

// UnmarshalSSZ ssz unmarshals the MerkleBlock object
func (m *MerkleBlock) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 20 {
		return ssz.ErrSize
	}

	tail := buf
	var o0, o2, o3 uint64

	// Offset (0) 'Header'
	if o0 = ssz.ReadOffset(buf[0:4]); o0 > size {
		return ssz.ErrOffset
	}

	if o0 < 20 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (1) 'Transactions'
	m.Transactions = ssz.UnmarshallUint64(buf[4:12])

	// Offset (2) 'Hashes'
	if o2 = ssz.ReadOffset(buf[12:16]); o2 > size || o0 > o2 {
		return ssz.ErrOffset
	}

	// Offset (3) 'Flags'
	if o3 = ssz.ReadOffset(buf[16:20]); o3 > size || o2 > o3 {
		return ssz.ErrOffset
	}

	// Field (0) 'Header'
	{
		buf = tail[o0:o2]
		if len(buf) > 256 {
			return ssz.ErrBytesLength
		}
		if cap(m.Header) == 0 {
			m.Header = make([]byte, 0, len(buf))
		}
		m.Header = append(m.Header, buf...)
	}

	// Field (2) 'Hashes'
	{
		buf = tail[o2:o3]
		num, err := ssz.DivideInt2(len(buf), 32, 104858)
		if err != nil {
			return err
		}
		m.Hashes = make([]*Hash, num)
		for ii := 0; ii < num; ii++ {
			if m.Hashes[ii] == nil {
				m.Hashes[ii] = new(Hash)
			}
			if err = m.Hashes[ii].UnmarshalSSZ(buf[ii*32 : (ii+1)*32]); err != nil {
				return err
			}
		}
	}

	// Field (3) 'Flags'
	{
		buf = tail[o3:]
		if len(buf) > 256 {
			return ssz.ErrBytesLength
		}
		if cap(m.Flags) == 0 {
			m.Flags = make([]byte, 0, len(buf))
		}
		m.Flags = append(m.Flags, buf...)
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the MerkleBlock object
func (m *MerkleBlock) SizeSSZ() (size int) {
	size = 20

	// Field (0) 'Header'
	size += len(m.Header)

	// Field (2) 'Hashes'
	size += len(m.Hashes) * 32

	// Field (3) 'Flags'
	size += len(m.Flags)

	return
}

// HashTreeRoot ssz hashes the MerkleBlock object
func (m *MerkleBlock) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(m)
}

// HashTreeRootWith ssz hashes the MerkleBlock object with a hasher
func (m *MerkleBlock) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Header'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(m.Header))
		if byteLen > 256 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.PutBytes(m.Header)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (256+31)/32)
	}

	// Field (1) 'Transactions'
	hh.PutUint64(m.Transactions)

	// Field (2) 'Hashes'
	{
		subIndx := hh.Index()
		num := uint64(len(m.Hashes))
		if num > 104858 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range m.Hashes {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 104858)
	}

	// Field (3) 'Flags'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(m.Flags))
		if byteLen > 256 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.PutBytes(m.Flags)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (256+31)/32)
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the MerkleBlock object
func (m *MerkleBlock) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(m)
}

// MarshalSSZ ssz marshals the MerkleBlockResponse object
func (m *MerkleBlockResponse) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(m)
}

// MarshalSSZTo ssz marshals the MerkleBlockResponse object to a target array
func (m *MerkleBlockResponse) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(4)

	// Offset (0) 'Data'
	dst = ssz.WriteOffset(dst, offset)
	for ii := 0; ii < len(m.Data); ii++ {
		offset += 4
		offset += m.Data[ii].SizeSSZ()
	}

	// Field (0) 'Data'
	if size := len(m.Data); size > 2000 {
		err = ssz.ErrListTooBigFn("MerkleBlockResponse.Data", size, 2000)
		return
	}
	{
		offset = 4 * len(m.Data)
		for ii := 0; ii < len(m.Data); ii++ {
			dst = ssz.WriteOffset(dst, offset)
			offset += m.Data[ii].SizeSSZ()
		}
	}
	for ii := 0; ii < len(m.Data); ii++ {
		if dst, err = m.Data[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	return
}

// UnmarshalSSZ ssz unmarshals the MerkleBlockResponse object
func (m *MerkleBlockResponse) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 4 {
		return ssz.ErrSize
	}

	tail := buf
	var o0 uint64

	// Offset (0) 'Data'
	if o0 = ssz.ReadOffset(buf[0:4]); o0 > size {
		return ssz.ErrOffset
	}

	if o0 < 4 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (0) 'Data'
	{
		buf = tail[o0:]
		num, err := ssz.DecodeDynamicLength(buf, 2000)
		if err != nil {
			return err
		}
		m.Data = make([]*MerkleBlock, num)
		err = ssz.UnmarshalDynamic(buf, num, func(indx int, buf []byte) (err error) {
			if m.Data[indx] == nil {
				m.Data[indx] = new(MerkleBlock)
			}
			if err = m.Data[indx].UnmarshalSSZ(buf); err != nil {
				return err
			}
			return nil
		})
		if err != nil {
			return err
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the MerkleBlockResponse object
func (m *MerkleBlockResponse) SizeSSZ() (size int) {
	size = 4

	// Field (0) 'Data'
	for ii := 0; ii < len(m.Data); ii++ {
		size += 4
		size += m.Data[ii].SizeSSZ()
	}

	return
}

// HashTreeRoot ssz hashes the MerkleBlockResponse object
func (m *MerkleBlockResponse) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(m)
}

// HashTreeRootWith ssz hashes the MerkleBlockResponse object with a hasher
func (m *MerkleBlockResponse) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Data'
	{
		subIndx := hh.Index()
		num := uint64(len(m.Data))
		if num > 2000 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range m.Data {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 2000)
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the MerkleBlockResponse object
func (m *MerkleBlockResponse) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(m)
}

// MarshalSSZ ssz marshals the ErrorResponse object
func (e *ErrorResponse) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(e)
}

// MarshalSSZTo ssz marshals the ErrorResponse object to a target array
func (e *ErrorResponse) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(4)

	// Offset (0) 'Message'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(e.Message)

	// Field (0) 'Message'
	if size := len(e.Message); size > 256 {
		err = ssz.ErrBytesLengthFn("ErrorResponse.Message", size, 256)
		return
	}
	dst = append(dst, e.Message...)

	return
}

// UnmarshalSSZ ssz unmarshals the ErrorResponse object
func (e *ErrorResponse) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 4 {
		return ssz.ErrSize
	}

	tail := buf
	var o0 uint64

	// Offset (0) 'Message'
	if o0 = ssz.ReadOffset(buf[0:4]); o0 > size {
		return ssz.ErrOffset
	}

	if o0 < 4 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (0) 'Message'
	{
		buf = tail[o0:]
		if len(buf) > 256 {
			return ssz.ErrBytesLength
		}
		if cap(e.Message) == 0 {
			e.Message = make([]byte, 0, len(buf))
		}
		e.Message = append(e.Message, buf...)
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the ErrorResponse object
func (e *ErrorResponse) SizeSSZ() (size int) {
	size = 4

	// Field (0) 'Message'
	size += len(e.Message)

	return
}

// HashTreeRoot ssz hashes the ErrorResponse object
func (e *ErrorResponse) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(e)
}

// HashTreeRootWith ssz hashes the ErrorResponse object with a hasher
func (e *ErrorResponse) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Message'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(e.Message))
		if byteLen > 256 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.PutBytes(e.Message)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (256+31)/32)
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the ErrorResponse object
func (e *ErrorResponse) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(e)
}

// MarshalSSZ ssz marshals the MetaData object
func (m *MetaData) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(m)
}

// MarshalSSZTo ssz marshals the MetaData object to a target array
func (m *MetaData) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'SeqNumber'
	dst = ssz.MarshalUint64(dst, m.SeqNumber)

	// Field (1) 'Subnets'
	if size := len(m.Subnets); size != 8 {
		err = ssz.ErrBytesLengthFn("MetaData.Subnets", size, 8)
		return
	}
	dst = append(dst, m.Subnets...)

	return
}

// UnmarshalSSZ ssz unmarshals the MetaData object
func (m *MetaData) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 16 {
		return ssz.ErrSize
	}

	// Field (0) 'SeqNumber'
	m.SeqNumber = ssz.UnmarshallUint64(buf[0:8])

	// Field (1) 'Subnets'
	if cap(m.Subnets) == 0 {
		m.Subnets = make([]byte, 0, len(buf[8:16]))
	}
	m.Subnets = append(m.Subnets, buf[8:16]...)

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the MetaData object
func (m *MetaData) SizeSSZ() (size int) {
	size = 16
	return
}

// HashTreeRoot ssz hashes the MetaData object
func (m *MetaData) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(m)
}

// HashTreeRootWith ssz hashes the MetaData object with a hasher
func (m *MetaData) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'SeqNumber'
	hh.PutUint64(m.SeqNumber)

	// Field (1) 'Subnets'
	if size := len(m.Subnets); size != 8 {
		err = ssz.ErrBytesLengthFn("MetaData.Subnets", size, 8)
		return
	}
	hh.PutBytes(m.Subnets)

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the MetaData object
func (m *MetaData) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(m)
}

// MarshalSSZ ssz marshals the Hash object
func (h *Hash) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(h)
}

// MarshalSSZTo ssz marshals the Hash object to a target array
func (h *Hash) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Hash'
	if size := len(h.Hash); size != 32 {
		err = ssz.ErrBytesLengthFn("Hash.Hash", size, 32)
		return
	}
	dst = append(dst, h.Hash...)

	return
}

// UnmarshalSSZ ssz unmarshals the Hash object
func (h *Hash) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 32 {
		return ssz.ErrSize
	}

	// Field (0) 'Hash'
	if cap(h.Hash) == 0 {
		h.Hash = make([]byte, 0, len(buf[0:32]))
	}
	h.Hash = append(h.Hash, buf[0:32]...)

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the Hash object
func (h *Hash) SizeSSZ() (size int) {
	size = 32
	return
}

// HashTreeRoot ssz hashes the Hash object
func (h *Hash) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(h)
}

// HashTreeRootWith ssz hashes the Hash object with a hasher
func (h *Hash) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Hash'
	if size := len(h.Hash); size != 32 {
		err = ssz.ErrBytesLengthFn("Hash.Hash", size, 32)
		return
	}
	hh.PutBytes(h.Hash)

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the Hash object
func (h *Hash) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(h)
}

// MarshalSSZ ssz marshals the StateRootReq object
func (s *StateRootReq) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(s)
}

// MarshalSSZTo ssz marshals the StateRootReq object to a target array
func (s *StateRootReq) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Block'
	if s.Block == nil {
		s.Block = new(Hash)
	}
	if dst, err = s.Block.MarshalSSZTo(dst); err != nil {
		return
	}

	return
}

// UnmarshalSSZ ssz unmarshals the StateRootReq object
func (s *StateRootReq) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 32 {
		return ssz.ErrSize
	}

	// Field (0) 'Block'
	if s.Block == nil {
		s.Block = new(Hash)
	}
	if err = s.Block.UnmarshalSSZ(buf[0:32]); err != nil {
		return err
	}

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the StateRootReq object
func (s *StateRootReq) SizeSSZ() (size int) {
	size = 32
	return
}

// HashTreeRoot ssz hashes the StateRootReq object
func (s *StateRootReq) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(s)
}

// HashTreeRootWith ssz hashes the StateRootReq object with a hasher
func (s *StateRootReq) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Block'
	if s.Block == nil {
		s.Block = new(Hash)
	}
	if err = s.Block.HashTreeRootWith(hh); err != nil {
		return
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the StateRootReq object
func (s *StateRootReq) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(s)
}

// MarshalSSZ ssz marshals the StateRootRsp object
func (s *StateRootRsp) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(s)
}

// MarshalSSZTo ssz marshals the StateRootRsp object to a target array
func (s *StateRootRsp) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Root'
	if s.Root == nil {
		s.Root = new(Hash)
	}
	if dst, err = s.Root.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (1) 'Has'
	dst = ssz.MarshalBool(dst, s.Has)

	return
}

// UnmarshalSSZ ssz unmarshals the StateRootRsp object
func (s *StateRootRsp) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 33 {
		return ssz.ErrSize
	}

	// Field (0) 'Root'
	if s.Root == nil {
		s.Root = new(Hash)
	}
	if err = s.Root.UnmarshalSSZ(buf[0:32]); err != nil {
		return err
	}

	// Field (1) 'Has'
	s.Has = ssz.UnmarshalBool(buf[32:33])

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the StateRootRsp object
func (s *StateRootRsp) SizeSSZ() (size int) {
	size = 33
	return
}

// HashTreeRoot ssz hashes the StateRootRsp object
func (s *StateRootRsp) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(s)
}

// HashTreeRootWith ssz hashes the StateRootRsp object with a hasher
func (s *StateRootRsp) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Root'
	if s.Root == nil {
		s.Root = new(Hash)
	}
	if err = s.Root.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (1) 'Has'
	hh.PutBool(s.Has)

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the StateRootRsp object
func (s *StateRootRsp) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(s)
}

// MarshalSSZ ssz marshals the SyncDAG object
func (s *SyncDAG) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(s)
}

// MarshalSSZTo ssz marshals the SyncDAG object to a target array
func (s *SyncDAG) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(8)

	// Offset (0) 'MainLocator'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(s.MainLocator) * 32

	// Offset (1) 'GraphState'
	dst = ssz.WriteOffset(dst, offset)
	if s.GraphState == nil {
		s.GraphState = new(GraphState)
	}
	offset += s.GraphState.SizeSSZ()

	// Field (0) 'MainLocator'
	if size := len(s.MainLocator); size > 32 {
		err = ssz.ErrListTooBigFn("SyncDAG.MainLocator", size, 32)
		return
	}
	for ii := 0; ii < len(s.MainLocator); ii++ {
		if dst, err = s.MainLocator[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (1) 'GraphState'
	if dst, err = s.GraphState.MarshalSSZTo(dst); err != nil {
		return
	}

	return
}

// UnmarshalSSZ ssz unmarshals the SyncDAG object
func (s *SyncDAG) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 8 {
		return ssz.ErrSize
	}

	tail := buf
	var o0, o1 uint64

	// Offset (0) 'MainLocator'
	if o0 = ssz.ReadOffset(buf[0:4]); o0 > size {
		return ssz.ErrOffset
	}

	if o0 < 8 {
		return ssz.ErrInvalidVariableOffset
	}

	// Offset (1) 'GraphState'
	if o1 = ssz.ReadOffset(buf[4:8]); o1 > size || o0 > o1 {
		return ssz.ErrOffset
	}

	// Field (0) 'MainLocator'
	{
		buf = tail[o0:o1]
		num, err := ssz.DivideInt2(len(buf), 32, 32)
		if err != nil {
			return err
		}
		s.MainLocator = make([]*Hash, num)
		for ii := 0; ii < num; ii++ {
			if s.MainLocator[ii] == nil {
				s.MainLocator[ii] = new(Hash)
			}
			if err = s.MainLocator[ii].UnmarshalSSZ(buf[ii*32 : (ii+1)*32]); err != nil {
				return err
			}
		}
	}

	// Field (1) 'GraphState'
	{
		buf = tail[o1:]
		if s.GraphState == nil {
			s.GraphState = new(GraphState)
		}
		if err = s.GraphState.UnmarshalSSZ(buf); err != nil {
			return err
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the SyncDAG object
func (s *SyncDAG) SizeSSZ() (size int) {
	size = 8

	// Field (0) 'MainLocator'
	size += len(s.MainLocator) * 32

	// Field (1) 'GraphState'
	if s.GraphState == nil {
		s.GraphState = new(GraphState)
	}
	size += s.GraphState.SizeSSZ()

	return
}

// HashTreeRoot ssz hashes the SyncDAG object
func (s *SyncDAG) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(s)
}

// HashTreeRootWith ssz hashes the SyncDAG object with a hasher
func (s *SyncDAG) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'MainLocator'
	{
		subIndx := hh.Index()
		num := uint64(len(s.MainLocator))
		if num > 32 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range s.MainLocator {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 32)
	}

	// Field (1) 'GraphState'
	if err = s.GraphState.HashTreeRootWith(hh); err != nil {
		return
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the SyncDAG object
func (s *SyncDAG) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(s)
}

// MarshalSSZ ssz marshals the SubDAG object
func (s *SubDAG) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(s)
}

// MarshalSSZTo ssz marshals the SubDAG object to a target array
func (s *SubDAG) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(40)

	// Field (0) 'SyncPoint'
	if s.SyncPoint == nil {
		s.SyncPoint = new(Hash)
	}
	if dst, err = s.SyncPoint.MarshalSSZTo(dst); err != nil {
		return
	}

	// Offset (1) 'GraphState'
	dst = ssz.WriteOffset(dst, offset)
	if s.GraphState == nil {
		s.GraphState = new(GraphState)
	}
	offset += s.GraphState.SizeSSZ()

	// Offset (2) 'Blocks'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(s.Blocks) * 32

	// Field (1) 'GraphState'
	if dst, err = s.GraphState.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (2) 'Blocks'
	if size := len(s.Blocks); size > 2000 {
		err = ssz.ErrListTooBigFn("SubDAG.Blocks", size, 2000)
		return
	}
	for ii := 0; ii < len(s.Blocks); ii++ {
		if dst, err = s.Blocks[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	return
}

// UnmarshalSSZ ssz unmarshals the SubDAG object
func (s *SubDAG) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 40 {
		return ssz.ErrSize
	}

	tail := buf
	var o1, o2 uint64

	// Field (0) 'SyncPoint'
	if s.SyncPoint == nil {
		s.SyncPoint = new(Hash)
	}
	if err = s.SyncPoint.UnmarshalSSZ(buf[0:32]); err != nil {
		return err
	}

	// Offset (1) 'GraphState'
	if o1 = ssz.ReadOffset(buf[32:36]); o1 > size {
		return ssz.ErrOffset
	}

	if o1 < 40 {
		return ssz.ErrInvalidVariableOffset
	}

	// Offset (2) 'Blocks'
	if o2 = ssz.ReadOffset(buf[36:40]); o2 > size || o1 > o2 {
		return ssz.ErrOffset
	}

	// Field (1) 'GraphState'
	{
		buf = tail[o1:o2]
		if s.GraphState == nil {
			s.GraphState = new(GraphState)
		}
		if err = s.GraphState.UnmarshalSSZ(buf); err != nil {
			return err
		}
	}

	// Field (2) 'Blocks'
	{
		buf = tail[o2:]
		num, err := ssz.DivideInt2(len(buf), 32, 2000)
		if err != nil {
			return err
		}
		s.Blocks = make([]*Hash, num)
		for ii := 0; ii < num; ii++ {
			if s.Blocks[ii] == nil {
				s.Blocks[ii] = new(Hash)
			}
			if err = s.Blocks[ii].UnmarshalSSZ(buf[ii*32 : (ii+1)*32]); err != nil {
				return err
			}
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the SubDAG object
func (s *SubDAG) SizeSSZ() (size int) {
	size = 40

	// Field (1) 'GraphState'
	if s.GraphState == nil {
		s.GraphState = new(GraphState)
	}
	size += s.GraphState.SizeSSZ()

	// Field (2) 'Blocks'
	size += len(s.Blocks) * 32

	return
}

// HashTreeRoot ssz hashes the SubDAG object
func (s *SubDAG) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(s)
}

// HashTreeRootWith ssz hashes the SubDAG object with a hasher
func (s *SubDAG) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'SyncPoint'
	if s.SyncPoint == nil {
		s.SyncPoint = new(Hash)
	}
	if err = s.SyncPoint.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (1) 'GraphState'
	if err = s.GraphState.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (2) 'Blocks'
	{
		subIndx := hh.Index()
		num := uint64(len(s.Blocks))
		if num > 2000 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range s.Blocks {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 2000)
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the SubDAG object
func (s *SubDAG) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(s)
}

// MarshalSSZ ssz marshals the ContinueSyncDAG object
func (c *ContinueSyncDAG) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(c)
}

// MarshalSSZTo ssz marshals the ContinueSyncDAG object to a target array
func (c *ContinueSyncDAG) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'SyncPoint'
	if c.SyncPoint == nil {
		c.SyncPoint = new(Hash)
	}
	if dst, err = c.SyncPoint.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (1) 'Start'
	if c.Start == nil {
		c.Start = new(Hash)
	}
	if dst, err = c.Start.MarshalSSZTo(dst); err != nil {
		return
	}

	return
}

// UnmarshalSSZ ssz unmarshals the ContinueSyncDAG object
func (c *ContinueSyncDAG) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 64 {
		return ssz.ErrSize
	}

	// Field (0) 'SyncPoint'
	if c.SyncPoint == nil {
		c.SyncPoint = new(Hash)
	}
	if err = c.SyncPoint.UnmarshalSSZ(buf[0:32]); err != nil {
		return err
	}

	// Field (1) 'Start'
	if c.Start == nil {
		c.Start = new(Hash)
	}
	if err = c.Start.UnmarshalSSZ(buf[32:64]); err != nil {
		return err
	}

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the ContinueSyncDAG object
func (c *ContinueSyncDAG) SizeSSZ() (size int) {
	size = 64
	return
}

// HashTreeRoot ssz hashes the ContinueSyncDAG object
func (c *ContinueSyncDAG) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(c)
}

// HashTreeRootWith ssz hashes the ContinueSyncDAG object with a hasher
func (c *ContinueSyncDAG) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'SyncPoint'
	if c.SyncPoint == nil {
		c.SyncPoint = new(Hash)
	}
	if err = c.SyncPoint.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (1) 'Start'
	if c.Start == nil {
		c.Start = new(Hash)
	}
	if err = c.Start.HashTreeRootWith(hh); err != nil {
		return
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the ContinueSyncDAG object
func (c *ContinueSyncDAG) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(c)
}

// MarshalSSZ ssz marshals the SyncQNR object
func (s *SyncQNR) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(s)
}

// MarshalSSZTo ssz marshals the SyncQNR object to a target array
func (s *SyncQNR) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(4)

	// Offset (0) 'Qnr'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(s.Qnr)

	// Field (0) 'Qnr'
	if size := len(s.Qnr); size > 300 {
		err = ssz.ErrBytesLengthFn("SyncQNR.Qnr", size, 300)
		return
	}
	dst = append(dst, s.Qnr...)

	return
}

// UnmarshalSSZ ssz unmarshals the SyncQNR object
func (s *SyncQNR) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 4 {
		return ssz.ErrSize
	}

	tail := buf
	var o0 uint64

	// Offset (0) 'Qnr'
	if o0 = ssz.ReadOffset(buf[0:4]); o0 > size {
		return ssz.ErrOffset
	}

	if o0 < 4 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (0) 'Qnr'
	{
		buf = tail[o0:]
		if len(buf) > 300 {
			return ssz.ErrBytesLength
		}
		if cap(s.Qnr) == 0 {
			s.Qnr = make([]byte, 0, len(buf))
		}
		s.Qnr = append(s.Qnr, buf...)
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the SyncQNR object
func (s *SyncQNR) SizeSSZ() (size int) {
	size = 4

	// Field (0) 'Qnr'
	size += len(s.Qnr)

	return
}

// HashTreeRoot ssz hashes the SyncQNR object
func (s *SyncQNR) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(s)
}

// HashTreeRootWith ssz hashes the SyncQNR object with a hasher
func (s *SyncQNR) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Qnr'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(s.Qnr))
		if byteLen > 300 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.PutBytes(s.Qnr)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (300+31)/32)
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the SyncQNR object
func (s *SyncQNR) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(s)
}

// MarshalSSZ ssz marshals the GetTxs object
func (g *GetTxs) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(g)
}

// MarshalSSZTo ssz marshals the GetTxs object to a target array
func (g *GetTxs) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(4)

	// Offset (0) 'Txs'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(g.Txs) * 32

	// Field (0) 'Txs'
	if size := len(g.Txs); size > 20000 {
		err = ssz.ErrListTooBigFn("GetTxs.Txs", size, 20000)
		return
	}
	for ii := 0; ii < len(g.Txs); ii++ {
		if dst, err = g.Txs[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	return
}

// UnmarshalSSZ ssz unmarshals the GetTxs object
func (g *GetTxs) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 4 {
		return ssz.ErrSize
	}

	tail := buf
	var o0 uint64

	// Offset (0) 'Txs'
	if o0 = ssz.ReadOffset(buf[0:4]); o0 > size {
		return ssz.ErrOffset
	}

	if o0 < 4 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (0) 'Txs'
	{
		buf = tail[o0:]
		num, err := ssz.DivideInt2(len(buf), 32, 20000)
		if err != nil {
			return err
		}
		g.Txs = make([]*Hash, num)
		for ii := 0; ii < num; ii++ {
			if g.Txs[ii] == nil {
				g.Txs[ii] = new(Hash)
			}
			if err = g.Txs[ii].UnmarshalSSZ(buf[ii*32 : (ii+1)*32]); err != nil {
				return err
			}
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the GetTxs object
func (g *GetTxs) SizeSSZ() (size int) {
	size = 4

	// Field (0) 'Txs'
	size += len(g.Txs) * 32

	return
}

// HashTreeRoot ssz hashes the GetTxs object
func (g *GetTxs) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(g)
}

// HashTreeRootWith ssz hashes the GetTxs object with a hasher
func (g *GetTxs) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Txs'
	{
		subIndx := hh.Index()
		num := uint64(len(g.Txs))
		if num > 20000 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range g.Txs {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 20000)
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the GetTxs object
func (g *GetTxs) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(g)
}

// MarshalSSZ ssz marshals the Transaction object
func (t *Transaction) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(t)
}

// MarshalSSZTo ssz marshals the Transaction object to a target array
func (t *Transaction) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(4)

	// Offset (0) 'TxBytes'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(t.TxBytes)

	// Field (0) 'TxBytes'
	if size := len(t.TxBytes); size > 1048576 {
		err = ssz.ErrBytesLengthFn("Transaction.TxBytes", size, 1048576)
		return
	}
	dst = append(dst, t.TxBytes...)

	return
}

// UnmarshalSSZ ssz unmarshals the Transaction object
func (t *Transaction) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 4 {
		return ssz.ErrSize
	}

	tail := buf
	var o0 uint64

	// Offset (0) 'TxBytes'
	if o0 = ssz.ReadOffset(buf[0:4]); o0 > size {
		return ssz.ErrOffset
	}

	if o0 < 4 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (0) 'TxBytes'
	{
		buf = tail[o0:]
		if len(buf) > 1048576 {
			return ssz.ErrBytesLength
		}
		if cap(t.TxBytes) == 0 {
			t.TxBytes = make([]byte, 0, len(buf))
		}
		t.TxBytes = append(t.TxBytes, buf...)
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the Transaction object
func (t *Transaction) SizeSSZ() (size int) {
	size = 4

	// Field (0) 'TxBytes'
	size += len(t.TxBytes)

	return
}

// HashTreeRoot ssz hashes the Transaction object
func (t *Transaction) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(t)
}

// HashTreeRootWith ssz hashes the Transaction object with a hasher
func (t *Transaction) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'TxBytes'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(t.TxBytes))
		if byteLen > 1048576 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.PutBytes(t.TxBytes)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (1048576+31)/32)
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the Transaction object
func (t *Transaction) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(t)
}

// MarshalSSZ ssz marshals the Transactions object
func (t *Transactions) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(t)
}

// MarshalSSZTo ssz marshals the Transactions object to a target array
func (t *Transactions) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(4)

	// Offset (0) 'Txs'
	dst = ssz.WriteOffset(dst, offset)
	for ii := 0; ii < len(t.Txs); ii++ {
		offset += 4
		offset += t.Txs[ii].SizeSSZ()
	}

	// Field (0) 'Txs'
	if size := len(t.Txs); size > 20000 {
		err = ssz.ErrListTooBigFn("Transactions.Txs", size, 20000)
		return
	}
	{
		offset = 4 * len(t.Txs)
		for ii := 0; ii < len(t.Txs); ii++ {
			dst = ssz.WriteOffset(dst, offset)
			offset += t.Txs[ii].SizeSSZ()
		}
	}
	for ii := 0; ii < len(t.Txs); ii++ {
		if dst, err = t.Txs[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	return
}

// UnmarshalSSZ ssz unmarshals the Transactions object
func (t *Transactions) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 4 {
		return ssz.ErrSize
	}

	tail := buf
	var o0 uint64

	// Offset (0) 'Txs'
	if o0 = ssz.ReadOffset(buf[0:4]); o0 > size {
		return ssz.ErrOffset
	}

	if o0 < 4 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (0) 'Txs'
	{
		buf = tail[o0:]
		num, err := ssz.DecodeDynamicLength(buf, 20000)
		if err != nil {
			return err
		}
		t.Txs = make([]*Transaction, num)
		err = ssz.UnmarshalDynamic(buf, num, func(indx int, buf []byte) (err error) {
			if t.Txs[indx] == nil {
				t.Txs[indx] = new(Transaction)
			}
			if err = t.Txs[indx].UnmarshalSSZ(buf); err != nil {
				return err
			}
			return nil
		})
		if err != nil {
			return err
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the Transactions object
func (t *Transactions) SizeSSZ() (size int) {
	size = 4

	// Field (0) 'Txs'
	for ii := 0; ii < len(t.Txs); ii++ {
		size += 4
		size += t.Txs[ii].SizeSSZ()
	}

	return
}

// HashTreeRoot ssz hashes the Transactions object
func (t *Transactions) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(t)
}

// HashTreeRootWith ssz hashes the Transactions object with a hasher
func (t *Transactions) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Txs'
	{
		subIndx := hh.Index()
		num := uint64(len(t.Txs))
		if num > 20000 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range t.Txs {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 20000)
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the Transactions object
func (t *Transactions) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(t)
}
